![](../Media/Pasted%20image%2020250316032310.png)

Process creation starts with kernel opening the image(executable) file and verification of it's proper format known as Portable Executable (PE). The file extension doesn't matter, only the actually content does.  After verification of the headers, the kernel creates new process kernel object and a thread kernel object, because a normal process is created with one thread that eventually should execute the main entry point.

At this point, the kernel maps the image to the address space of the new process, as well as `NtDll.Dll`. `NtDll` is mapped to every process (except Minimal and Pico processes), since it has very important duties in the final stage of process creation (outlined below) as well being the trampoline from which system calls are invoked. The final major step which is still carried out by the creator process is notifying the Windows subsystem process (`Csrss.exe`) of the fact that a new process and thread have been created. (`Csrss` can be thought of as a helper to the kernel for managing some aspects of Windows subsystem processes).

At this point, from the kernel’s point of view, the process has been created successfully, so the process creation function invoked by the caller (typically `CreateProcess`) returns success. However, the new process is not yet ready to execute its initial code. The second part of process initialization must be carried out in the context of the new process, by the newly created thread.

Some developers believe that the first thing that runs in a new process is the executable’s main function. This is far from the truth, however. There is a lot going on before the actual main function starts running. The star of this part is `NtDll`, as there is no other OS level code in the process at this time. `NtDll` has several duties at this point.

First, it creates the user-mode management object for the process, known as the Process Environment Block (PEB) and the user mode management object for the first thread called Thread Environment Block (TEB). These structures are partially-documented (in `<winternl.h>`), and officially should not be used directly by developers. That said, there are cases where these structures are useful, especially when trying to achieve things that are difficult to do otherwise.

> [!note] 
>  The current thread’s TEB is accessible via `NtCurrentTeb()`, while the PEB of the current process is available via `NtCurrentTeb()->ProcessEnvironmentBlock`.

Then some other initializations are carried out, including the creation of the default process heap, creation and initialization of the default process thread pool and more. For full details, consult the Windows Internals book.

The last major part before the entry point can start execution is to load required DLLs. This part of `NtDll` is often referred to as the Loader. The loader looks at the import section of the executable, which includes all the libraries the executable depends upon. These typically include the Windows subsystem DLLs such as `kernel32.dll`, `user32.dll`, `gdi32.dll` and `advapi32.dll`.

To get a sense for these import libraries, we can use the DumpBin.exe tool available as part of the Windows SDK and Visual Studio installation. Open the Developer Command Prompt to gain easy access to the various tools and type the following to look at the imports for Notepad.exe:

```cmd
Dump of file c:\Windows\System32\notepad.exe

File Type: EXECUTABLE IMAGE

Section contains the following imports:

	GDI32.dll

		140022788 Import Address Table
		
		1400289E8 Import Name Table
		
			0 time date stamp
			
			0 Index of first forwarder reference
			
				35C SelectObject
				
				2D0 GetTextFaceW 1C2 EnumFontsW

	USER32.dll

		140022840 Import Address Table
		
		140028AA0 Import Name Table
		
			0 time date stamp
			
			0 Index of first forwarder reference
		
				364 SetThreadDpiAwarenessContext
				
				2AD PostMessageW
				
				BA DialogBoxParamW

	msvcrt.dll
	
		140022FD8 Import Address Table 140029238 Import Name Table
	
			0 time date stamp
			
			0 Index of first forwarder reference
	
				2F ?terminate@@YAXXZ
				
				496 memset 

	api-ms-win-core-libraryloader-l1-2-0.dll 
	
		140022C60 Import Address Table 
		
		140028EC0 Import Name Table
		
			0 time date stamp
			
			0 Index of first forwarder reference
			
				F GetModuleFileNameA
				
				18 LoadLibraryExW
				
				13 GetModuleHandleExW
```


For each required DLL, dumpbin shows the imported functions from that DLL, the functions actually used by the executable. But some of the DLL names may look weird, and you won't find them as actual files. For instance `api-ms-win-core-libraryloader-l1-2-0.dll`. It's an API Set, which is an indirect mapping from a contract (the API Set) to an actual implementation DLL (sometimes referred to as a Host).

