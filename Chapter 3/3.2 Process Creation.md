![](../Media/Pasted%20image%2020250316032310.png)

Process creation starts with kernel opening the image(executable) file and verification of it's proper format known as Portable Executable (PE). The file extension doesn't matter, only the actually content does.  After verification of the headers, the kernel creates new process kernel object and a thread kernel object, because a normal process is created with one thread that eventually should execute the main entry point.

At this point, the kernel maps the image to the address space of the new process, as well as `NtDll.Dll`. `NtDll` is mapped to every process (except Minimal and Pico processes), since it has very important duties in the final stage of process creation (outlined below) as well being the trampoline from which system calls are invoked. The final major step which is still carried out by the creator process is notifying the Windows subsystem process (`Csrss.exe`) of the fact that a new process and thread have been created. (`Csrss` can be thought of as a helper to the kernel for managing some aspects of Windows subsystem processes).

At this point, from the kernel’s point of view, the process has been created successfully, so the process creation function invoked by the caller (typically `CreateProcess`) returns success. However, the new process is not yet ready to execute its initial code. The second part of process initialization must be carried out in the context of the new process, by the newly created thread.

Some developers believe that the first thing that runs in a new process is the executable’s main function. This is far from the truth, however. There is a lot going on before the actual main function starts running. The star of this part is `NtDll`, as there is no other OS level code in the process at this time. `NtDll` has several duties at this point.

First, it creates the user-mode management object for the process, known as the Process Environment Block (PEB) and the user mode management object for the first thread called Thread Environment Block (TEB). These structures are partially-documented (in `<winternl.h>`), and officially should not be used directly by developers. That said, there are cases where these structures are useful, especially when trying to achieve things that are difficult to do otherwise.

> [!note] 
>  The current thread’s TEB is accessible via `NtCurrentTeb()`, while the PEB of the current process is available via `NtCurrentTeb()->ProcessEnvironmentBlock`.

Then some other initializations are carried out, including the creation of the default process heap, creation and initialization of the default process thread pool and more. For full details, consult the Windows Internals book.

The last major part before the entry point can start execution is to load required DLLs. This part of `NtDll` is often referred to as the Loader. The loader looks at the import section of the executable, which includes all the libraries the executable depends upon. These typically include the Windows subsystem DLLs such as `kernel32.dll`, `user32.dll`, `gdi32.dll` and `advapi32.dll`.

To get a sense for these import libraries, we can use the DumpBin.exe tool available as part of the Windows SDK and Visual Studio installation. Open the Developer Command Prompt to gain easy access to the various tools and type the following to look at the imports for Notepad.exe: