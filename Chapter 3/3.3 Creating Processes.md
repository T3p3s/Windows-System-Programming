`CreateProcess` function needs an actual executable name. For instance if you would pass something like `C:\MyData\data.txt` assuming `data.txt` is some text file - will fail process creation. `CreateProcess` accepts only `EXE` files, even if `.exe` wasn't specified at the end, it will search the registry based on the file extension to locate the associated program to execute.  

It's a BOOL function, return TRUE on success.
```c
BOOL CreateProcess(

_In_opt_ PCTSTR pApplicationName, 
_Inout_opt_ PTSTR pCommandLine,
_In_opt_ PSECURITY_ATTRIBUTES pProcessAttributes, 
_In_opt_ PSECURITY_ATTRIBUTES pThreadAttributes,
_In_ BOOL bInheritHandles, 
_In_ DWORD dwCreationFlags, 
_In_opt_ PVOID pEnvironment,
_In_opt_ PCTSTR pCurrentDirectory, 
_In_ PSTARTUPINFO pStartupInfo, 
_Out_ PPROCESS_INFORMATION lpProcessInformation);
```

If successful, the real information is available via the last argument of type `PROCESS_INFORMATION`

```c
typedef struct _PROCESS_INFORMATION { 
HANDLE hProcess; 
HANDLE hThread; 
DWORD dwProcessId; 
DWORD dwThreadId; 
} PROCESS_INFORMATION, *PPROCESS_INFORMATION;
```

`pStartupinfo` uses `STARTUPINFO` structure. Zeroing the structure is important, otherwise it holds junk values which will likely cause `CreateProcess` to fail. Example:

```c
STARTUPINFO si = {sizeof(si)};
CreateProcess(..., &si, ...);
```

Example of creating process:
```c
#include <stdio.h>
#include <Windows.h>


int main() {

	WCHAR name[] = L"notepad.exe";
	STARTUPINFO si = { sizeof(si) };
	PROCESS_INFORMATION pi;

	BOOL CreatingProcess = CreateProcess(NULL, name, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);

	if (!CreatingProcess) {
		printf("[-] Wasn't able to create the process: %d \n", GetLastError());
		return -1;
	}
	printf("[+] Process created. PID = %d \n", pi.dwProcessId);

	//WaitForSingleObject(pi.hProcess, INFINITE); 
	//printf("Notepad terminated. \n");

	DWORD rv = ::WaitForSingleObject(pi.hProcess, 10000); 
	if (rv == WAIT_TIMEOUT)
		printf("Notepad still running...\n");
	else if (rv == WAIT_OBJECT_0)
		printf("Notepad terminated.\n");
	else // WAIT_ERROR (unlikely in this case)
		printf("Error! %d\n", ::GetLastError());

	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);
	

	return 0;
}
```

`WaitForSingleObject` puts the calling thread into a wait state until the object in question changes to the signaled state or the timeout expires. In case of `INFINITE (-1)`, it never expires.